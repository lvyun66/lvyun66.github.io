---
title: 数据结构之链表详解
date: 2018-11-13 19:11:05
tags:
    - 数据结构
    - 链表
categories:
    - 数据结构
comments: true
---

`链表`是数据结构中最基本、最常用以及占有重要地位数据存储方式；例如：可以用链表实现队列、实现跳表以及堆栈。链接是一种`线性表`，但是并不会按照线性的顺序存储，而是在每一个的节点中存储下一个节点的指针。

由于链表不是按照顺序存储（即内存中的地址不必是连续），因此插入的时间复杂度为`O(1)`，相比数据的插入时间复杂度`O(n)`来说要快得多；但也正因为这个特性，在链表的查找不能像数组(`复杂度为O(1)`)一样通过下标去访问特定的节点，只能通过遍历的方式去查找(`O(n)`)。

## 对比数组
**优点**
1. 能够充分利用计算机的内存空间，实现灵活的内存动态管理
2. 快速在任意的节点插入或者删除

**缺点**
1. 没有数组随机读取的优点，查找速度比速度慢
2. 增加节点的指针域，空间开销相比数据大

**链表、数组时间复杂度对比**
```markdown
| 操作\结构 | 数组 | 链表 |
| --------- | ---- | ---- |
| 查找      | O(1) | O(n) |
| 插入      | O(n) | O(1) |
| 删除      | O(n) | O(1) |
```

## 分类

1. 单向链表
2. 双向链表
3. 循环链表
4. 块状链表
5. 其他结构

文章会重点介绍`单向链表`、`双向链表`以及`循环链表`的实现。

## 单向链表
`单向链表`不仅包含值，还包含链接到下一个节点的`引用字段`。通过这种方式，将链表的所有节点按顺序连接起来。

### PHP如何表示一个链表
```php
class LinkedList
{
    public $value = null;
    /**
     * @var \Lvyun\Struct\LinkedList
     */
    public $next = null;

    public function __construct($value)
    {
        $this->value = $value;
    }
}
```

### 访问数据
```php
// 根据索引查找
public function get($index)
{
    $current = $this;
    $i = 0;
    $value = -1;

    while (true) {
        if (!$current->value && !$current->next) {
            break;
        }
        if (!$current->next && $i != $index) {
            break;
        }
        if ($index == $i) {
            $value = $current->value;
            break;
        }
        $current = $current->next;
        $i++;
    }

    return $value;
}
```

### 插入
```php
// 在头部插入
public function addAtHead($value)
{
    if (!$this->value) {
        $this->value = $value;
        return;
    }

    $current = new LinkedList($this->value);
    $current->next = $this->next;

    $this->value = $value;
    $this->next = $current;
}

// 在尾部插入
public function addAtTail($value)
{
    if (!$this->value) {
        $this->value = $value;
        return;
    }

    $current = $this;
    while ($current->next) {
        $current = $current->next;
    }
    $last = new LinkedList($value);
    $current->next = $last;
}

// 在指定位置插入
public function addAtIndex($index, $value)
{
    $current = $this;
    $i = 0;

    while (true) {
        if ($index == $i) {
            if (!$current->value) {
                $this->addAtHead($value);
                break;
            }
            if (!$current->next) {
                $this->addAtTail($value);
                break;
            }
            $n = new LinkedList($value);
            $n->next = $current->next;
            $current->next = $n;
            break;
        }
        $current = $current->next;
        $i++;
    }

    return $value;
}
```

### 删除
```php
// 删除头节点
public function deleteAdHead()
{
    if (!$this->value) {
        return;
    }
    if (!$this->next) {
        $this->value = null;
        $this->next = null;
    }
    $this->value = $this->next->value;
    $this->next = $this->next->next;
}

// 删除尾节点
public function deleteAtTail()
{
    if (!$this->value) {
        return;
    }
    $prev = $current = $this;
    while ($current->next) {
        if ($current->next) {
            $prev = $current;
        }
        $current = $current->next;
    }
    if ($prev === $current) {
        $this->value = null;
        $this->next = null;
    }
    $prev->next = null;
}

// 删除指定节点
public function deleteAtIndex($index)
{
    $current = $prev = $this;
    $i = 0;
    while (true) {
        if ($index == $i) {
            if ($current->next) {
                $prev->next = $current->next;
                break;
            } else {
                $this->deleteAtTail();
            }
        }
        $prev = $current;
        $current = $current->next;
        $i++;
    }
}
```

## 2018-11-15 09:41:02 Thursday 更新
```php
<?php

namespace Lvyun\Struct;

class Node
{
    public $data = null;
    /**
     * @var \Lvyun\Struct\Node
     */
    public $next = null;
}

class LinkedList
{
    public $head;

    public function __construct()
    {
        $node = new Node();
        $this->head = $node;
    }

    public function get($index)
    {
        $current = $this->head;
        if (!$current->data) {
            return -1;
        }

        $i = 0;
        while ($current) {
            if ($i == $index) {
                return $current->data;
            }
            $current = $current->next;
            $i++;
        }

        return -1;
    }

    public function addAtHead($val)
    {
        $node = new Node();
        $node->data = $val;

        $current = $this->head;
        if ($current->data) {
            $node->next = $current;
        }
        $this->head = $node;

        return;
    }

    public function addAtTail($val)
    {
        $node = new Node();
        $node->data = $val;

        $current = $this->head;

        if (!$current->data) {
            $this->head = $node;
            return;
        }

        while ($current->next) {
            $current = $current->next;
        }
        $current->next = $node;
    }

    public function addAtIndex($index, $val)
    {
        $node = new Node();
        $node->data = $val;

        $current = $this->head;

        if (!$current->data) {
            $this->head = $node;
            return;
        }

        $i = 0;
        while ($current) {
            if ($i == $index) {
                $node->next = $current->next;
                $current->next = $node;
                return;
            }
            $i++;
            $current = $current->next;
        }
    }

    public function deleteAtHead()
    {
        $current = $this->head;
        if (!$current->data) {
            return -1;
        }
        if (!$current->next) {
            $this->head = new Node();
            return 1;
        }
        $this->head = $current->next;

        return true;
    }

    public function deleteAtTail()
    {
        $current = $prev = $this->head;

        if (!$current->data) {
            return -1;
        }
        if (!$current->next) {
            $this->head = new Node();
            return 1;
        }

        while ($current->next) {
            $prev = $current;
            $current = $current->next;
        }
        $prev->next = null;

        return 1;
    }

    public function deleteAtIndex($index)
    {
        $current = $prev = $this->head;

        if (!$current->data) {
            return -1;
        }
        if (!$current->next) {
            $this->head = new Node();
            return 1;
        }

        $i = 0;
        while ($current) {
            if ($index == $i) {
                $prev->next = $current->next;
                return 1;
            }
            $i++;
            $prev = $current;
            $current = $current->next;
        }

        return 1;
    }
}
```
