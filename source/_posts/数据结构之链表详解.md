---
title: 数据结构之链表详解
date: 2018-11-13 19:11:05
tags:
    - 数据结构
    - 链表
categories:
    - 数据结构
comments: true
---

`链表`是数据结构中最基本、最常用以及占有重要地位数据存储方式；例如：可以用链表实现队列、实现跳表以及堆栈。链接是一种`线性表`，但是并不会按照线性的顺序存储，而是在每一个的节点中存储下一个节点的指针。

由于链表不是按照顺序存储（即内存中的地址不必是连续），因此插入的时间复杂度为`O(1)`，相比数据的插入时间复杂度`O(n)`来说要快得多；但也正因为这个特性，在链表的查找不能像数组(`复杂度为O(1)`)一样通过下标去访问特定的节点，只能通过遍历的方式去查找(`O(n)`)。

## 对比数组

**优点**

1. 能够充分利用计算机的内存空间，实现灵活的内存动态管理
2. 快速在任意的节点插入或者删除

**缺点**

1. 没有数组随机读取的优点，查找速度比速度慢
2. 增加节点的指针域，空间开销相比数据大

**链表、数组时间复杂度对比**

```markdown
+-----------+------+------+
| 操作\结构 | 数组 | 链表 |
|   查找    | O(1) | O(n) |
|   插入    | O(n) | O(1) |
|   删除    | O(n) | O(1) |
+-----------+------+------+
```

## 分类

1. 单向链表
2. 双向链表
3. 循环链表
4. 块状链表
5. 其他结构

文章会重点介绍`单向链表`、`双向链表`以及`循环链表`的实现。

## 单向链表

`单向链表`不仅包含值，还包含链接到下一个节点的`引用字段`。通过这种方式，将链表的所有节点按顺序连接起来。

下面是用PHP实现的链表，其中`LinkedList`表示一个一个链表，同时也表示链表中的一个`node`；其中`value`表示当前节点的值，`$next`表示下一节点的引用。

当`$value、$next`都为`null`，链表为空；`$next`为`null`，则表示当前节点为链表最后一个节点。在`LinkedList`用`$this`表示链表的第一个节点。

```php
class LinkedList
{
    public $value = null;
    /**
     * @var LinkedList
     */
    public $next = null;

    public function __construct($value)
    {
        $this->value = $value;
    }
}
```

### 访问数据

`因为链表不能像数组一样能通过数组下标随机访问，只能通过遍历链表获取值。`当访问的索引值等于要查找的索引值则是要查找的值。

```php
// 根据索引查找
public function get($index)
{
    $current = $this;
    $i = 0;
    $value = -1;

    while (true) {
        if (!$current->value && !$current->next) {
            break;
        }
        if (!$current->next && $i != $index) {
            break;
        }
        if ($index == $i) {
            $value = $current->value;
            break;
        }
        $current = $current->next;
        $i++;
    }

    return $value;
}
```

### 插入

在数组中插入值，需要移动插入节点之后所有的数据，因此数组的插入操作时间复杂度为`O(n)`；而链表的插入不同于数组的插入，链表的插入得益于链表的存储方式，不需要移动后续的节点，时间复杂度为`O(1)`。

插入分为`头插法`和`尾插法`。顾名思义，`头插法`就是每次都在链表的头部插入数组，链表的顺序与输入的顺序相反；`尾插法`每次在链表的尾节点插入数据，链表的顺序与输入顺序一致。

**特别注意：** 插入的时间复杂度虽然未`O(1)`，但是链表查找的时间复杂度为`O(n)`。

```php
// 在头部插入
public function addAtHead($value)
{
    if (!$this->value) {
        $this->value = $value;
        return;
    }

    $current = new LinkedList($this->value);
    $current->next = $this->next;

    $this->value = $value;
    $this->next = $current;
}

// 在尾部插入
public function addAtTail($value)
{
    if (!$this->value) {
        $this->value = $value;
        return;
    }

    $current = $this;
    while ($current->next) {
        $current = $current->next;
    }
    $last = new LinkedList($value);
    $current->next = $last;
}

// 在指定位置插入
public function addAtIndex($index, $value)
{
    $current = $this;
    $i = 0;

    while (true) {
        if ($index == $i) {
            if (!$current->value) {
                $this->addAtHead($value);
                break;
            }
            if (!$current->next) {
                $this->addAtTail($value);
                break;
            }
            $n = new LinkedList($value);
            $n->next = $current->next;
            $current->next = $n;
            break;
        }
        $current = $current->next;
        $i++;
    }

    return $value;
}
```

### 删除

链表的删除操作时间复杂度为`O(1)`。

**步骤**

1. 查找当前节点`$current`的上一个节点`$prev`和下一个节点`$next`；
2. 将`$prev`的next指向`$next`

```php
// 删除头节点
public function deleteAdHead()
{
    if (!$this->value) {
        return;
    }
    if (!$this->next) {
        $this->value = null;
        $this->next = null;
    }
    $this->value = $this->next->value;
    $this->next = $this->next->next;
}

// 删除尾节点
public function deleteAtTail()
{
    if (!$this->value) {
        return;
    }
    $prev = $current = $this;
    while ($current->next) {
        if ($current->next) {
            $prev = $current;
        }
        $current = $current->next;
    }
    if ($prev === $current) {
        $this->value = null;
        $this->next = null;
    }
    $prev->next = null;
}

// 删除指定节点
public function deleteAtIndex($index)
{
    $current = $prev = $this;
    $i = 0;
    while (true) {
        if ($index == $i) {
            if ($current->next) {
                $prev->next = $current->next;
                break;
            } else {
                $this->deleteAtTail();
            }
        }
        $prev = $current;
        $current = $current->next;
        $i++;
    }
}
```

## 2018-11-15 09:41:02 Thursday 更新

```php
<?php

namespace Lvyun\Struct;

class Node
{
    public $data = null;
    /**
     * @var \Lvyun\Struct\Node
     */
    public $next = null;
}

class LinkedList
{
    public $head;

    public function __construct()
    {
        $node = new Node();
        $this->head = $node;
    }

    public function get($index)
    {
        $current = $this->head;
        if (!$current->data) {
            return -1;
        }

        $i = 0;
        while ($current) {
            if ($i == $index) {
                return $current->data;
            }
            $current = $current->next;
            $i++;
        }

        return -1;
    }

    public function addAtHead($val)
    {
        $node = new Node();
        $node->data = $val;

        $current = $this->head;
        if ($current->data) {
            $node->next = $current;
        }
        $this->head = $node;

        return;
    }

    public function addAtTail($val)
    {
        $node = new Node();
        $node->data = $val;

        $current = $this->head;

        if (!$current->data) {
            $this->head = $node;
            return;
        }

        while ($current->next) {
            $current = $current->next;
        }
        $current->next = $node;
    }

    public function addAtIndex($index, $val)
    {
        $node = new Node();
        $node->data = $val;

        $current = $this->head;

        if (!$current->data) {
            $this->head = $node;
            return;
        }

        $i = 0;
        while ($current) {
            if ($i == $index) {
                $node->next = $current->next;
                $current->next = $node;
                return;
            }
            $i++;
            $current = $current->next;
        }
    }

    public function deleteAtHead()
    {
        $current = $this->head;
        if (!$current->data) {
            return -1;
        }
        if (!$current->next) {
            $this->head = new Node();
            return 1;
        }
        $this->head = $current->next;

        return true;
    }

    public function deleteAtTail()
    {
        $current = $prev = $this->head;

        if (!$current->data) {
            return -1;
        }
        if (!$current->next) {
            $this->head = new Node();
            return 1;
        }

        while ($current->next) {
            $prev = $current;
            $current = $current->next;
        }
        $prev->next = null;

        return 1;
    }

    public function deleteAtIndex($index)
    {
        $current = $prev = $this->head;

        if (!$current->data) {
            return -1;
        }
        if (!$current->next) {
            $this->head = new Node();
            return 1;
        }

        $i = 0;
        while ($current) {
            if ($index == $i) {
                $prev->next = $current->next;
                return 1;
            }
            $i++;
            $prev = $current;
            $current = $current->next;
        }

        return 1;
    }
}
```

## 2018-11-27 09:06:14 Tue 更新

```golang
package leetcode

type MyLinkedList struct {
    head *node
}

type node struct {
    data int
    next *node
}

const DefaultValue = -1

/** Initialize your data structure here. */
func Constructor() MyLinkedList {
    return MyLinkedList{
        head: nil,
    }
}

/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
func (this *MyLinkedList) Get(index int) int {
    var current = this.head
    var i = 0
    for current != nil {
        if index == i {
            return current.data
        }
        i++
        current = current.next
    }
    return DefaultValue
}

/** Add a node of value val before the first element of the linked list.
After the insertion, the new node will be the first node of the linked list.
 */
func (this *MyLinkedList) AddAtHead(val int) {
    var current = this.head
    node := &node{data: val, next: current}
    this.head = node
}

/** Append a node of value val to the last element of the linked list. */
func (this *MyLinkedList) AddAtTail(val int) {
    var current = this.head
    node := &node{data: val, next: nil}
    if current == nil {
        this.head = node
        return
    }
    for current != nil {
        if current.next == nil {
            current.next = node
            return
        }
        current = current.next
    }
}

/** Add a node of value val before the index-th node in the linked list.
If index equals to the length of linked list, the node will be appended to the end of linked list.
If index is greater than the length, the node will not be inserted.
 */
func (this *MyLinkedList) AddAtIndex(index int, val int) {
    var (
        current = this.head
        prev    = this.head
        i       = 0
    )
    if current == nil && index == 0 {
        this.head = &node{data: val, next: nil}
        return
    }
    if index == 0 {
        this.AddAtHead(val)
        return
    }
    // head: 1->2->3->nil
    for current != nil {
        if index == i {
            node := &node{data: val, next: current}
            prev.next = node
            return
        }
        i++
        prev = current
        current = current.next
    }
    if current == nil && index == i {
        this.AddAtTail(val)
        return
    }
}

/** Delete the index-th node in the linked list, if the index is valid. */
func (this *MyLinkedList) DeleteAtIndex(index int) {
    var (
        current = this.head
        prev    = this.head
        i       = 0
    )
    if current == nil {
        return
    }
    if index == 0 && current.next == nil {
        this.head = nil
        return
    }
    for current != nil {
        if index == i {
            prev.next = current.next
            return
        }
        i++
        prev = current
        current = current.next
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * obj := Constructor();
 * param_1 := obj.Get(index);
 * obj.AddAtHead(val);
 * obj.AddAtTail(val);
 * obj.AddAtIndex(index,val);
 * obj.DeleteAtIndex(index);
 */
```
