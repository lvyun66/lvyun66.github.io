<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LvYun`s Blog</title>
  
  <subtitle>Web开发 ｜ PHP</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lvyun66.github.io/"/>
  <updated>2019-08-30T08:19:44.318Z</updated>
  <id>https://lvyun66.github.io/</id>
  
  <author>
    <name>Lv Yun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP中require和include区别？</title>
    <link href="https://lvyun66.github.io/2019/08/29/PHP-require-include%E5%8C%BA%E5%88%AB/"/>
    <id>https://lvyun66.github.io/2019/08/29/PHP-require-include区别/</id>
    <published>2019-08-29T09:29:00.000Z</published>
    <updated>2019-08-30T08:19:44.318Z</updated>
    
    <content type="html"><![CDATA[<p>在Web项目中，include和require是模块化设计的基础，当然现在我们我们都是直接使用Composer来管理模块之间的相互依赖，但spl_autoload_register底层的设计中依然用到include和require。</p><p>被包含文件先按照参数的给出的路径寻找，如果没有给出目录（只有文件名）时按照include_path指定的目录寻找。如果在include_path下没有找到文件则include最后才在调用脚本文件所在的目录和当前工作目录下寻找。</p><a id="more"></a><p><strong>include和require没有本质上的区别，唯一的区别在于错误级别上，当文件无法被正常加载时include会抛出warming，而require会抛出error错误。</strong></p><h2 id="include的基本用法及特点"><a href="#include的基本用法及特点" class="headerlink" title="include的基本用法及特点"></a>include的基本用法及特点</h2><ol><li>被包含的文件将继承include所在行具有的全部变量范围，比如调用文件前面定义了一些变量，那么这些变量就能够在被包含的文件中使用，反之，被包含文件中定义的变量也将从include调用初开始被调用文件使用；</li><li>被包含文件中定义的函数、类在include执行之后将可以被随处调用，即具有全局作用域；</li><li>include是在运行时加载文件并执行，而不是在编译阶段。</li></ol><p><strong>include是一个特殊的语言结构，其参数不需要括号。</strong></p><h2 id="require的基本用户及特点"><a href="#require的基本用户及特点" class="headerlink" title="require的基本用户及特点"></a>require的基本用户及特点</h2><p>用法基本与include一致，除了处理失败的处理方式不同之外。</p><h2 id="include-once和require-once"><a href="#include-once和require-once" class="headerlink" title="include_once和require_once"></a>include_once和require_once</h2><p><code>include_once</code>语句和<code>include</code>语句完全相同，唯一区别是PHP会检查该文件是否已经被包含过，如果是则不会再次包含。</p><p><code>require_once</code>和<code>require</code>也是同理。</p><blockquote><p>最后引用鸟哥的一篇文章 <a href="http://www.laruence.com/2012/09/12/2765.html" target="_blank" rel="noopener">再一次, 不要使用(include/require)_once</a>，我们应该尽量少使用(include/require)_once</p></blockquote><h2 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h2><blockquote><p><a href="https://www.kancloud.cn/nickbai/php7/363301" target="_blank" rel="noopener">PHP7内核剖析</a><br><a href="http://www.laruence.com/2012/09/12/2765.html" target="_blank" rel="noopener">再一次, 不要使用(include/require)_once</a></p></blockquote><h2 id="Thinks"><a href="#Thinks" class="headerlink" title="Thinks"></a>Thinks</h2><p>感谢你的阅读。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Web项目中，include和require是模块化设计的基础，当然现在我们我们都是直接使用Composer来管理模块之间的相互依赖，但spl_autoload_register底层的设计中依然用到include和require。&lt;/p&gt;
&lt;p&gt;被包含文件先按照参数的给出的路径寻找，如果没有给出目录（只有文件名）时按照include_path指定的目录寻找。如果在include_path下没有找到文件则include最后才在调用脚本文件所在的目录和当前工作目录下寻找。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://lvyun66.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://lvyun66.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP算术运算符的加号应该如何使用？</title>
    <link href="https://lvyun66.github.io/2019/08/22/PHP%E4%B8%AD%E7%9A%84%E5%8A%A0%E5%8F%B7/"/>
    <id>https://lvyun66.github.io/2019/08/22/PHP中的加号/</id>
    <published>2019-08-22T17:42:49.000Z</published>
    <updated>2019-08-30T08:19:44.318Z</updated>
    
    <content type="html"><![CDATA[<p>加号是PHP的一个关键词，常用语算术运算中，例如1+2、2.0+3.0等等。但在PHP中加号（+）不仅仅可以在数字之间相加，还可以在别的类型之间进行运算。加号运算符（+）都是在哪些类型之间运算呢？下面让我们一一列举。</p><a id="more"></a><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$foo = <span class="number">1</span>;</span><br><span class="line">$bar = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">echo</span> $foo + $bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>PHP的加号运算符还可以在数组之间应用，例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">($a, $b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $a += $b;</span><br><span class="line">    var_dump($a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// array(3) &#123;</span></span><br><span class="line"><span class="comment">//   [0]=&gt;</span></span><br><span class="line"><span class="comment">//   int(1)</span></span><br><span class="line"><span class="comment">//   [1]=&gt;</span></span><br><span class="line"><span class="comment">//   int(2)</span></span><br><span class="line"><span class="comment">//   [2]=&gt;</span></span><br><span class="line"><span class="comment">//   int(5)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>数组之间相加，前面的数组会把键值相同后面的数组覆盖。如果前面的数组的键不在后面的数组中，那么将会丢着这部分。</p><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>字符之间使用加号，会抛出致命错误。</p><h2 id="Thinks"><a href="#Thinks" class="headerlink" title="Thinks"></a>Thinks</h2><p>感谢你的阅读…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;加号是PHP的一个关键词，常用语算术运算中，例如1+2、2.0+3.0等等。但在PHP中加号（+）不仅仅可以在数字之间相加，还可以在别的类型之间进行运算。加号运算符（+）都是在哪些类型之间运算呢？下面让我们一一列举。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://lvyun66.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://lvyun66.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP从本质上分析echo、print、print_r三者之间的区别？</title>
    <link href="https://lvyun66.github.io/2019/08/21/PHP-echo-print-print_r%E5%8C%BA%E5%88%AB/"/>
    <id>https://lvyun66.github.io/2019/08/21/PHP-echo-print-print_r区别/</id>
    <published>2019-08-21T09:38:25.000Z</published>
    <updated>2019-08-30T08:19:44.318Z</updated>
    
    <content type="html"><![CDATA[<p><code>echo</code>、<code>print</code>、<code>print_r</code>在PHP开发中都是常见的，但每次只管用，不理解它们之前的区别，包括在很多的面试中都会提及三者之间的区别。我们都知道它们都可以输出并打印字符串，但本质上它们有什么区别呢？</p><a id="more"></a><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>PHP官方文档(<a href="https://www.php.net/manual/zh/function.echo.php" target="_blank" rel="noopener">echo</a>)说明：</p><blockquote><p>echo ( string $arg1 [, string $… ] ) : void</p><p>echo 不是一个函数（它是一个语言结构）， 因此你不一定要使用小括号来指明参数，单引号，双引号都可以。 echo （不像其他语言构造）不表现得像一个函数， 所以不能总是使用一个函数的上下文。 另外，如果你想给echo 传递多个参数， 那么就不能使用小括号。</p><p>和 print 最主要的不同之处是， echo 接受参数列表，并且没有返回值。</p></blockquote><p>从上面的说明可以看出echo是语言结构而不是函数。那么什么是语言结构呢？说简单的就是PHP的关键词，语法的一部分。而函数由代码块组成，从源码的角度说，也就是基于Zend引擎的基础来实现的。</p><h3 id="词法解析-amp-语法分析"><a href="#词法解析-amp-语法分析" class="headerlink" title="词法解析&amp;语法分析"></a>词法解析&amp;语法分析</h3><p>PHP是脚本语言，因此所有的符号都会先经过词法解析和语法分析阶段，这两个阶段分别由<code>lex</code>和<code>yacc</code>完成。分别对应PHP源码中的<code>Zend/zend_language_scanner.l</code>和<code>Zend/zend_language_parser.y</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ST_IN_SCRIPTING&gt;&quot;echo&quot; &#123;</span><br><span class="line">RETURN_TOKEN(T_ECHO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">token:</span><br><span class="line">%token T_ECHO       &quot;echo (T_ECHO)&quot;</span><br><span class="line"></span><br><span class="line">statement:</span><br><span class="line">...</span><br><span class="line">T_ECHO echo_expr_list &apos;;&apos;&#123; $$ = $2; &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">echo_expr_list:</span><br><span class="line">echo_expr_list &apos;,&apos; echo_expr &#123; $$ = zend_ast_list_add($1, $3); &#125;</span><br><span class="line">|echo_expr &#123; $$ = zend_ast_create_list(1, ZEND_AST_STMT_LIST, $1); &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">echo_expr:</span><br><span class="line">expr &#123; $$ = zend_ast_create(ZEND_AST_ECHO, $1); &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr:</span><br><span class="line">variable&#123; $$ = $1; &#125;</span><br><span class="line">|expr_without_variable&#123; $$ = $1; &#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>PHP语句先执行词法分析得到TOKEN，然后通过语法分析关联TOKEN得到抽象语法树（AST）。具体的输出我还没弄明白，暂时先写这么多。</p><p>详细请参考<a href="https://juejin.im/post/5b60648e6fb9a04fcd586af1#heading-9" target="_blank" rel="noopener">深入理解PHP之echo</a></p><h2 id="print-r"><a href="#print-r" class="headerlink" title="print_r"></a>print_r</h2><p>PHP官方文档(<a href="https://www.php.net/manual/zh/function.print-r.php" target="_blank" rel="noopener">print_r</a>)说明：</p><blockquote><p>print_r ( mixed $expression [, bool $return = FALSE ] ) : mixed</p><p>print_r() 以人类易读的格式显示一个变量的信息。</p><p>print_r()、 var_dump()、 var_export() 都会显示对象 protected 和 private 的属性。 Class 的静态属性（static） 则不会显示。</p></blockquote><p>print_r是PHP的一个函数，有返回值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;echo&lt;/code&gt;、&lt;code&gt;print&lt;/code&gt;、&lt;code&gt;print_r&lt;/code&gt;在PHP开发中都是常见的，但每次只管用，不理解它们之前的区别，包括在很多的面试中都会提及三者之间的区别。我们都知道它们都可以输出并打印字符串，但本质上它们有什么区别呢？&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://lvyun66.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://lvyun66.github.io/tags/PHP/"/>
    
      <category term="源码分析" scheme="https://lvyun66.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>PHP如何获取客户端真实IP?</title>
    <link href="https://lvyun66.github.io/2019/08/20/PHP%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9C%9F%E5%AE%9EIP/"/>
    <id>https://lvyun66.github.io/2019/08/20/PHP如何获取客户端真实IP/</id>
    <published>2019-08-20T19:34:08.000Z</published>
    <updated>2019-08-30T08:19:44.318Z</updated>
    
    <content type="html"><![CDATA[<p>PHP获取客户端IP的操作很常见，记录用户登录IP、根据IP判断用户位置、IP白名单都是一些基本的业务需求。因此如何获取准确的IP地址也是这些需求的必要前提。</p><p>要想准确获取IP地址，我们先了解HTTP header中和IP相关的信息以及代理服务器和应用服务器是如何传递IP地址的。</p><a id="more"></a><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>说到IP，就和HTTP协议离不开，HTTP header中和IP相关的部分包括：<code>X-Forwarded-For</code>、<code>via</code>、<code>X-Real-IP</code>等。</p><h3 id="X-Forwarded-For"><a href="#X-Forwarded-For" class="headerlink" title="X-Forwarded-For"></a>X-Forwarded-For</h3><p><code>X-Forwarded-For</code>是一个HTTP扩展头部，在HTTP/1.1(RFC 2616)中并没有对它的定义，是之后才被写入<a href="https://tools.ietf.org/html/rfc7239" target="_blank" rel="noopener">RFC 7239 (Forwarded HTTP Extension)</a>标准中的。</p><p>XFF请求头格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For: client, proxy1, proxy2</span><br></pre></td></tr></table></figure><p>经过多个代理服务器后，如果严格安装XFF标准，服务端最终会收到以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For: client, IP1, IP2, IP3</span><br></pre></td></tr></table></figure><p>也就是说代理服务器会把上一个代理服务器的IP地址追加到<code>X-Forwarded-For</code>后面，因此<code>X-Forwarded-For</code>的第一个值就是客户端的真正IP。由于<code>X-Forwarded-For</code>很容易被篡改，所有获取的的客户端IP不是真实存在的。</p><h2 id="NGINX"><a href="#NGINX" class="headerlink" title="NGINX"></a>NGINX</h2><p>接下来我们了解下NGINX作为代理服务器时设置的一些参数，<code>HTTP-X-FORWARDED-FOR</code>、<code>X-REAL-IP</code>、<code>REMOTE-ADDR</code>。</p><h3 id="HTTP-X-FORWARDED-FOR"><a href="#HTTP-X-FORWARDED-FOR" class="headerlink" title="HTTP-X-FORWARDED-FOR"></a>HTTP-X-FORWARDED-FOR</h3><p><code>HTTP-X-FORWARDED-FOR</code>就是HTTP协议中的<code>X-Forwarded-For</code>，在设置<code>HTTP-X-FORWARDED-FOR</code>有多重方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header HTTP-X-FORWARDED-FOR $http_x_forwarded_for;</span><br><span class="line">// 将上一个的HTTP-X-FORWARDED-FOR值复制给当前HTTP-X-FORWARDED-FOR，即忽略上一次代理的转发</span><br><span class="line"></span><br><span class="line">proxy_set_header HTTP-X-FORWARDED-FOR $remote_addr;</span><br><span class="line">// HTTP-X-FORWARDED-FOR被赋值为上一个代理服务器的IP</span><br><span class="line"></span><br><span class="line">proxy_set_header HTTP-X-FORWARDED-FOR $proxy_add_x_forwarded_for;</span><br><span class="line">// $proxy_add_x_forwarded_for = $http_x_forwarded_for + $remote_addr</span><br></pre></td></tr></table></figure><h3 id="X-REAL-IP"><a href="#X-REAL-IP" class="headerlink" title="X-REAL-IP"></a>X-REAL-IP</h3><p>是自定义HTTP header，需要在服务端自行实现该头部协议。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header X-REAL-IP $remote_addr;</span><br></pre></td></tr></table></figure><h3 id="REMOTE-ADDR"><a href="#REMOTE-ADDR" class="headerlink" title="REMOTE-ADDR"></a>REMOTE-ADDR</h3><p>因为HTTP协议是应用层协议，因此header中的信息都是可以被篡改，都是不安全的。</p><p><code>REMOTE-ADDR</code>是解析TCP/IP协议中的IP地址，如果这个值不正确，TCP/IP就不会建立连接，这个值是安全可靠的，我们可以通过这个值获取上一个代理服务器的真实IP。</p><h2 id="PHP获取客户端IP"><a href="#PHP获取客户端IP" class="headerlink" title="PHP获取客户端IP"></a>PHP获取客户端IP</h2><p>在PHP中获取客户端IP可以通过以下的三种方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$_SERVER[<span class="string">'REMOTE-ADDR'</span>];</span><br><span class="line">$_SERVER[<span class="string">'HTTP-X-FORWARDED-FOR'</span>];</span><br><span class="line">$_SERVER[<span class="string">'HTTP-REAL-IP'</span>];</span><br></pre></td></tr></table></figure><p>如果后端服务没有通过nginx做代理直接连接，<code>$_SERVER[&#39;REMOTE-ADDR&#39;]</code>可以直接获取客户端的真实IP；但如果使用了代理，则获取到就是代理服务器的IP。</p><p>使用NGINX等web server进行反向代理时，在nginx配置正确的情况下，要使用<code>$_SERVER[&#39;HTTP-X-FORWARDED-FOR&#39;]</code>或<code>$_SERVER[&#39;HTTP-REAL-IP&#39;]</code>获取客户端真实IP。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们需要根据NGINX的配置来选择正确的方式获取IP。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PHP获取客户端IP的操作很常见，记录用户登录IP、根据IP判断用户位置、IP白名单都是一些基本的业务需求。因此如何获取准确的IP地址也是这些需求的必要前提。&lt;/p&gt;
&lt;p&gt;要想准确获取IP地址，我们先了解HTTP header中和IP相关的信息以及代理服务器和应用服务器是如何传递IP地址的。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://lvyun66.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://lvyun66.github.io/tags/PHP/"/>
    
      <category term="HTTP" scheme="https://lvyun66.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>PHP源码之strrev函数分析</title>
    <link href="https://lvyun66.github.io/2019/04/09/PHP%E6%BA%90%E7%A0%81%E4%B9%8Bstrrev%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/"/>
    <id>https://lvyun66.github.io/2019/04/09/PHP源码之strrev函数分析/</id>
    <published>2019-04-09T19:03:01.000Z</published>
    <updated>2019-08-30T08:19:44.318Z</updated>
    
    <content type="html"><![CDATA[<p>PHP函数<code>strrev</code>的作用是反转字符串，传入一个带反转的字符串，并返回反转后的字符串。</p><a id="more"></a><h2 id="函数原型及用法"><a href="#函数原型及用法" class="headerlink" title="函数原型及用法"></a>函数原型及用法</h2><p>函数原型如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strrev(string $str): string</span><br></pre></td></tr></table></figure><p>PHP官方文档：<a href="https://www.php.net/manual/en/function.strrev.php" target="_blank" rel="noopener">strrev</a> 描述了函数的具体使用方法。</p><p>使用场景如下：</p><ol><li>反转字符串或一串数字</li><li>判断数字是否为回文数</li></ol><h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>源文件位于<code>php-src/ext/standard/string.c</code>文件中，是PHP标准扩展string字符串扩展中的一个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &#123;&#123;&#123; proto string strrev(string str)</span></span><br><span class="line"><span class="comment">   Reverse a string */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ZEND_INTRIN_SSSE3_NATIVE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tmmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">PHP_FUNCTION(strrev)    <span class="comment">// 声明函数名称 strrev</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// strrev参数str，类型为zend_string类型的指针</span></span><br><span class="line">    zend_string *str;</span><br><span class="line">    <span class="comment">// 分别表示参数的开始字符和结束字符地址</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s, *e;</span><br><span class="line">    <span class="comment">// 函数结果n的值的地址</span></span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="comment">// 函数返回结果n，类型同样为zend_string类型的指针</span></span><br><span class="line">    zend_string *n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析函数参数并绑定到str</span></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        Z_PARAM_STR(str)</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请长度为 ZSTR_LEN(str) 的内存，STR_LEN(str)为字符串长度</span></span><br><span class="line">    n = zend_string_alloc(ZSTR_LEN(str), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 返回结果n的值的地址，通过地址的方式访问字符串</span></span><br><span class="line">    p = ZSTR_VAL(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取str的首元素的指针</span></span><br><span class="line">    s = ZSTR_VAL(str);</span><br><span class="line">    <span class="comment">// 字符串的末位字符地址</span></span><br><span class="line">    e = s + ZSTR_LEN(str);</span><br><span class="line">    <span class="comment">// 防止内存越界，保证e在s &lt;= e &lt; s + ZSTR_LEN(str)范围之内</span></span><br><span class="line">    --e;</span><br><span class="line">    <span class="comment">// 这里还没理解作用是什么？</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ZEND_INTRIN_SSSE3_NATIVE</span></span><br><span class="line">    <span class="keyword">if</span> (e - s &gt; <span class="number">15</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> __m128i <span class="built_in">map</span> = _mm_set_epi8(</span><br><span class="line">                <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">                <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>,</span><br><span class="line">                <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>,</span><br><span class="line">                <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> __m128i str = _mm_loadu_si128((__m128i *)(e - <span class="number">15</span>));</span><br><span class="line">            _mm_storeu_si128((__m128i *)p, _mm_shuffle_epi8(str, <span class="built_in">map</span>));</span><br><span class="line">            p += <span class="number">16</span>;</span><br><span class="line">            e -= <span class="number">16</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (e - s &gt; <span class="number">15</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">while</span> (e &gt;= s) &#123; <span class="comment">// 终止条件为，当指向str末尾的指针小于开头的指针，终止循环</span></span><br><span class="line">        <span class="comment">// 把str的尾字符与n的首字符交换，达到反转效果</span></span><br><span class="line">        *p++ = *e--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将指针赋值为空</span></span><br><span class="line">    *p = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">// 返回结果n</span></span><br><span class="line">    RETVAL_NEW_STR(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* &#125;&#125;&#125; */</span></span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>从源码可以看出，反转字符串用到了两个数组，一个是参数、另一个是返回结果。函数通过遍历参数str，实现函数的反转。</p><p>当字符串长度大于15可能会对函数进行优化。具体如何优化，后面对源码理解更加深刻之后再来填坑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PHP函数&lt;code&gt;strrev&lt;/code&gt;的作用是反转字符串，传入一个带反转的字符串，并返回反转后的字符串。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://lvyun66.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://lvyun66.github.io/tags/PHP/"/>
    
      <category term="源码" scheme="https://lvyun66.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>PHP之静态变量和成员变量有何区别</title>
    <link href="https://lvyun66.github.io/2019/04/07/PHP%E4%B9%8B%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB/"/>
    <id>https://lvyun66.github.io/2019/04/07/PHP之静态变量和成员变量有何区别/</id>
    <published>2019-04-07T22:38:05.000Z</published>
    <updated>2019-08-30T08:19:44.318Z</updated>
    
    <content type="html"><![CDATA[<p>todo…</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;todo…&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP源码分析之如何表示弱类型</title>
    <link href="https://lvyun66.github.io/2019/04/07/PHP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E5%BC%B1%E7%B1%BB%E5%9E%8B/"/>
    <id>https://lvyun66.github.io/2019/04/07/PHP源码分析之如何表示弱类型/</id>
    <published>2019-04-07T22:35:13.000Z</published>
    <updated>2019-08-30T08:19:44.318Z</updated>
    
    <content type="html"><![CDATA[<p>todo…</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;todo…&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP函数intval和int区别</title>
    <link href="https://lvyun66.github.io/2019/04/07/PHP%E5%87%BD%E6%95%B0intval%E5%92%8Cint%E5%8C%BA%E5%88%AB/"/>
    <id>https://lvyun66.github.io/2019/04/07/PHP函数intval和int区别/</id>
    <published>2019-04-07T22:32:53.000Z</published>
    <updated>2019-08-30T08:19:44.318Z</updated>
    
    <content type="html"><![CDATA[<p>TODO…</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TODO…&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>费了九牛二虎之力安装miniube</title>
    <link href="https://lvyun66.github.io/2019/03/22/Miniube%E5%AE%89%E8%A3%85/"/>
    <id>https://lvyun66.github.io/2019/03/22/Miniube安装/</id>
    <published>2019-03-22T17:57:01.000Z</published>
    <updated>2019-08-30T08:19:44.318Z</updated>
    
    <content type="html"><![CDATA[<p>由于不可抗拒的因素，导致在国内安装minikube变得十分的复杂和繁琐。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于不可抗拒的因素，导致在国内安装minikube变得十分的复杂和繁琐。&lt;/p&gt;
    
    </summary>
    
      <category term="k8s" scheme="https://lvyun66.github.io/categories/k8s/"/>
    
    
      <category term="k8s" scheme="https://lvyun66.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Golang可变参数函数，传入切片会发生什么？</title>
    <link href="https://lvyun66.github.io/2019/03/21/Golang%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E4%BC%A0%E5%85%A5%E5%88%87%E7%89%87%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/"/>
    <id>https://lvyun66.github.io/2019/03/21/Golang可变参数函数传入切片会发生什么/</id>
    <published>2019-03-21T12:00:27.000Z</published>
    <updated>2019-08-30T08:19:44.318Z</updated>
    
    <content type="html"><![CDATA[<p>可变参数函数又可以称为”变长函数“，因为函数参数长度可以变化。会用<code>name ...type</code>这种形式表示可变参数。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可变参数函数又可以称为”变长函数“，因为函数参数长度可以变化。会用&lt;code&gt;name ...type&lt;/code&gt;这种形式表示可变参数。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="https://lvyun66.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://lvyun66.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang那些不容忽视的细节</title>
    <link href="https://lvyun66.github.io/2019/03/20/Golang%E9%82%A3%E4%BA%9B%E4%B8%8D%E5%AE%B9%E5%BF%BD%E8%A7%86%E7%9A%84%E7%BB%86%E8%8A%82/"/>
    <id>https://lvyun66.github.io/2019/03/20/Golang那些不容忽视的细节/</id>
    <published>2019-03-20T14:32:23.000Z</published>
    <updated>2019-08-30T08:19:44.318Z</updated>
    
    <content type="html"><![CDATA[<p>go语言的语法简单，但使用起来确有很多细节，下面是日常开发中遇到的细节问题。</p><a id="more"></a><h2 id="除法运算符中关于常量的坑"><a href="#除法运算符中关于常量的坑" class="headerlink" title="除法运算符中关于常量的坑"></a>除法运算符中关于常量的坑</h2><p>两个数相除，是向下取整或向上取整还是返回浮点数？</p><p>首先，go中整数不能除以浮点数，浮点数也不能除整数，否则会发生精度值溢出的情况，这在go中是不被允许的。</p><p>其次，除法运算符的运算结果类型是由除数决定的，因为运算是从左到右的顺序执行。如果除数为整数，则结果向下取整；若为浮点数，则结果同样为浮点数。</p><p>但如果除数或者被除数都常量，结果又如何呢？我们要知道，常量可以通过常量声明或者显式的给定类型，也可以通过在变量声明、赋值或者表达式的操作数中隐式地使用；因此如果除数类型确定，而被除数类型未确定，则被除数的类型根据出来来推断。例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="number">2.2</span></span><br><span class="line">fmt.Printf(<span class="string">"var a type = %T\n"</span>, a)</span><br><span class="line">fmt.Printf(<span class="string">"var b type = %T\n"</span>, b)</span><br><span class="line">fmt.Printf(<span class="string">"var c type = %T\n"</span>, c)</span><br><span class="line">fmt.Printf(<span class="string">"var d type = %T\n"</span>, d)</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"a/b ="</span>, a/b)</span><br><span class="line"><span class="comment">//fmt.Println(a / d)</span></span><br><span class="line">fmt.Println(<span class="string">"a/2 ="</span>, a/<span class="number">2</span>)</span><br><span class="line">fmt.Println(<span class="string">"a/2.0 ="</span>, a/<span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"c/d ="</span>, c/d)</span><br><span class="line">fmt.Println(<span class="string">"c/2 ="</span>, c/<span class="number">2</span>)</span><br><span class="line"><span class="comment">//fmt.Println(c / b)</span></span><br><span class="line">fmt.Println(<span class="string">"c/2.0 ="</span>, c/<span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"1/b ="</span>, <span class="number">1</span>/b)</span><br><span class="line">fmt.Println(<span class="string">"1/2 ="</span>, <span class="number">1</span>/<span class="number">2</span>)</span><br><span class="line">fmt.Println(<span class="string">"1.0/b ="</span>, <span class="number">1.0</span>/b)</span><br><span class="line">fmt.Println(<span class="string">"1.0/2,0 ="</span>, <span class="number">1.0</span>/<span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// var a type = int</span></span><br><span class="line"><span class="comment">// var b type = int</span></span><br><span class="line"><span class="comment">// var c type = float64</span></span><br><span class="line"><span class="comment">// var d type = float64</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// a/b = 0</span></span><br><span class="line"><span class="comment">// a/2 = 0</span></span><br><span class="line"><span class="comment">// a/2.0 = 0</span></span><br><span class="line"><span class="comment">// c/d = 0.45454545454545453</span></span><br><span class="line"><span class="comment">// c/2 = 0.5</span></span><br><span class="line"><span class="comment">// c/2.0 = 0.5</span></span><br><span class="line"><span class="comment">// 1/b = 0</span></span><br><span class="line"><span class="comment">// 1/2 = 0</span></span><br><span class="line"><span class="comment">// 1.0/b = 0</span></span><br><span class="line"><span class="comment">// 1.0/2,0 = 0.5</span></span><br></pre></td></tr></table></figure><p>从上面的测试结果可以看出：</p><ol><li>除数为常量、被除数为整数，则结果为整数</li><li>除数为整数、被除数为常量，则结果为整数</li><li>除数为常量、被除数为浮点数，则结果为浮点数</li><li>除数为浮点数、被除数为常量，则结果为浮点数</li><li>除数为整数、被除数为浮点数。不被允许</li><li>除数为浮点数、被除数为整数，不被允许</li></ol><p><strong>最终我们得出一个结论，就是表达式中的常量的类型会自动根据表达式中其他的变量类型决定，如果表达式中都为常量，这返回类型为常量的默认类型</strong></p><p>这个关于golang中常量的类型装换的解释：<a href="https://golang.org/ref/spec#Constants" target="_blank" rel="noopener">https://golang.org/ref/spec#Constants</a></p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go语言的语法简单，但使用起来确有很多细节，下面是日常开发中遇到的细节问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="https://lvyun66.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://lvyun66.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群教程</title>
    <link href="https://lvyun66.github.io/2019/02/14/Redis%E9%9B%86%E7%BE%A4%E6%95%99%E7%A8%8B/"/>
    <id>https://lvyun66.github.io/2019/02/14/Redis集群教程/</id>
    <published>2019-02-14T19:10:25.000Z</published>
    <updated>2019-08-30T08:19:44.322Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是翻译redis官网的一篇文章，并且加上作者的一些理解而成。若理解错误，请提出批评。</p><p>原文请查看 <strong><a href="https://redis.io/topics/cluster-tutorial#redis-cluster-101" target="_blank" rel="noopener">Redis cluster tutorial</a></strong></p><a id="more"></a><p>本文档是对Redis Cluster的简要介绍，它不适用复杂的方法来理解分布式系统概念。它提供了有关如何设置集群、测试和操作集群的说明，而不涉及Redis集群规范中涵盖的详细信息，而只是从用户的角度描述系统的行为方式。</p><p>但是，本教程尝试以最终用户的角度提供有关Redis Cluster的可用性和一致性特征的信息，以简明易懂的方式说明。</p><p><strong>请注意，本教程需要Redis 3.0或更高版本。</strong></p><p>如果你计划运行严格的Redis集群部署，则应该阅读更加正式的规范，即使不是严格的要求。但是，从本文档开始，使用Redis Cluster一段时间，然后才阅读规范是一个好主意。</p><h2 id="Redis-Cluster-101"><a href="#Redis-Cluster-101" class="headerlink" title="Redis Cluster 101"></a>Redis Cluster 101</h2><p>Redis Cluster提供了一种运行Redis安装的方法，其中数据在多个节点之间自动分片。</p><p>Redis Cluster还在分区期间提供了一定程度的可用性，实际上是在某些节点发生故障或无法通信时继续运行的能力。但是，如果发生较大的故障（例如，当大多数主设备不可用时），集群将停止运行。</p><p>所以实际上，你对Redis Cluster有什么看法？</p><ul><li>能够在多节点之间自动拆分数据集</li><li>当节点的子集遇到故障或无法与集群的其他部分通信时，能够继续操作</li></ul><h2 id="Redis-Cluster-TCP端口"><a href="#Redis-Cluster-TCP端口" class="headerlink" title="Redis Cluster TCP端口"></a>Redis Cluster TCP端口</h2><p><strong>每个Redis Cluster节点都需要打开两个TCP连接。用于为客户端提供服务的普通Redis TCP端口，例如6379，加上通过想数据端口添加10000获得的端口，因此在示例中为16379。</strong></p><p>第二个高端口用户集群总线，这是使用二进制通信的节点到节点通信信道。节点使用集群总线进行故障检测，配置更新，故障转移授权等。客户端永远不应尝试集群总线端口，但始终使用正常的Redis命令端口，但确保在防火墙中打开这两个端口，否则Redis Cluster节点将无法通信。</p><p>命令端口和集群总线端口偏移是固定的，始终为10000。</p><p>请注意，要是每个Redis节点正常工作，你需要：</p><ol><li>用于与客户端通信的普通客户端端口（通常为6379）对所有需要访问集群的客户端以及所有其他集群节点（使用客户端端口进行密钥迁移）开放。</li><li>必须可以从所有其他集群节点访问集群总线客户端（客户端端口+10000）。</li></ol><p>如果不打开两个TCP端口，则集群将无法按预期工作。</p><p>集群总线使用不同的二进制协议进行节点到节点的数据交换，这更适合于使用很少的带宽和处理时间在节点之间交互信息。</p><h2 id="Redis-Cluster和Docker"><a href="#Redis-Cluster和Docker" class="headerlink" title="Redis Cluster和Docker"></a>Redis Cluster和Docker</h2><p>目前，Redis Cluster不支持NATed环境，也不支持重新映射IP地址或TCP端口的一般环境。</p><p>Docker使用一种称为端口映射的技术：与程序认为使用的端口相比，在Docker容器内运行的程序可能会使用不同的端口。这对使用同一服务器中同时使用相同端口运行多个容器非常有用。</p><p>为了使Redis Cluster和Docker兼容，你需要使用Docker的Host网络模式。有关更多信息，请查看Docker文件中的-net=host选项。</p><h2 id="Redis-Cluster数据分片"><a href="#Redis-Cluster数据分片" class="headerlink" title="Redis Cluster数据分片"></a>Redis Cluster数据分片</h2><p>Redis Cluster不使用一致的散列，而是使用不同形式的分片，其中每个键在概念上都是我们称之为散列槽（hash slot）的一部分。</p><p>Redis Cluster中有16384个散列槽，为了计算给定密钥的散列槽，我们只需要采用密钥模数16384的CRC16。</p><p>Redis Cluster中每个节点都负责散列槽的子集，例如，你可能拥有一个3节点的集群，其中：</p><ul><li>Node A包含0-5500的散列槽</li><li>Node B包含5501-11000的散列槽</li><li>Node C包含11001-16383的散列槽</li></ul><p>这允许轻松添加和删除集群中的节点。例如，我想增加一个Node D，我需要将一些散列槽从Node A、Node B、Node C移动到Node D，如果我想删除Node A，只需要将Node A的节点移动到Node B和Node C中。当Node A为空时，可以完全从集群中删除它。</p><p>因为将散列槽从一个节点移动到另一个节点不需要停止操作，添加和删除节点或者更改节点所持有的散列槽的百分比，不需要任何停机时间。</p><p>只要涉及单个命令执行（或整个事务或Lua脚本执行）的所有键都属于同一个散列槽，Redis Cluster就支持多个键操作。用户可以通过使用称为哈希标记（hash tag）的概念强制多个密钥称为同一个散列槽的一部分。</p><p>哈希标记（Hash Tags）记录在Redis Cluster规范中，但要点是，如果一个键中{}括号之间有一个子串，则只对该字符串的内容进行哈希处理，所以例如这个{foo}密钥和另一个{foo}密钥保证在同一个散列槽中，并且可以在具有多个密钥作为参数的命令中一起使用。</p><h2 id="Redis-Cluster主从模型"><a href="#Redis-Cluster主从模型" class="headerlink" title="Redis Cluster主从模型"></a>Redis Cluster主从模型</h2><p>为了在主节点子集发生故障或无法与大多数节点通信时保持可用，Redis Cluster使用主从模式，其中每个散列槽从1（主机本身）到N个副本（N-1附加从机节点）。</p><p>在具有Node A、B、C的示例集群中，如果Node B发生故障，则集群无法继续，因为我们不再能在5501-11000范围内提供服务哈希位置的方法。</p><p>但是，当创建集群时（或稍后），我们会向每个主节点添加一个从节点，为了使最终的簇由作为主节点A、B、C和作为从节点的A1、B1、C1组成，如果Node B发生故障，系统能够继续使用。</p><p>Node B1复制B，B失败，集群将节点B1升级为新的主节点，并将继续正常使用。</p><p>但请注意，如果节点B和B1同时发生故障，Redis Cluster将无法继续运行。</p><h2 id="Redis-Cluster一致性保证"><a href="#Redis-Cluster一致性保证" class="headerlink" title="Redis Cluster一致性保证"></a>Redis Cluster一致性保证</h2><p>Redis Cluster无法保证强一致性。实际上，这意味着在某些条件下，Redis Cluster可能会丢失系统向客户端确认的写入。</p><p>Redis Cluster可能丢失写入的第一个原因是它使用异步复制。这意味着在写入期间会发生一下情况：</p><ul><li>客户端写入主节点B</li><li>主节点B向客户端回复确认</li><li>主节点B将写入复制到从节点B1、B2、B3</li></ul><p>正如所见，B在回复客户端之前不等待来自B1、B2、B3的确认，因为这是对Redis来说是一个禁止的延迟惩罚，因此，如果客户端写入某些内容，主节点B确认写入，但在能够将写入发送到其他从属节点之前崩溃，其中一个从属服务器（未接收到写入）可以被提升为主节点，那么将会永远丢失写入。</p><p>这与大多数配置为每秒将数据刷新到磁盘的数据库非常相似，因此，由于过去不涉及分布式系统的传统数据库系统的经验，这是一个你已经能够推理的场景。同样，可以在回复客户端之前强制数据库刷新磁盘上的数据来提供一致性，但这通常会导致性能过低，在Redis Cluster的情况下，这相当于同步复制。</p><p>基本上需要在性能和一致性之间进行权衡。</p><p>Redis Cluster在绝对需要支持同步写入，通过WAIT命令实现，这使得丢失写入的可能性大大降低，但请注意，即时使用同步复制，Redis Cluster也不会实现强一致性：在更复杂的故障情况下，始终有可能将无法接收写入的从节点选为主节点。</p><p>还有另一个值得注意的地方是，Redis Cluster将丢失写入，这种情况发生在网络分区中，其中客户端与少数实例（只是包括主服务器）隔离。</p><p>以六个节点为例，包括Node A、B、C、A1、B1、C1，3个主节点和3个从节点。还有一个客户端Z1。在发生分区之后，可能在分区的一侧有Node A、C、A1、B1、C1，在另一侧有B和Z1。Z1仍然可以写入B，它将接受其写入。如果分区在很短的时间内恢复，集群将继续正常运行。但是，如果分区持续足够的时间是B1在分区的多数侧被提升为主节点，则Z1发送给B的写入将丢失。</p><p>请注意，Z1将能够发送到B的写入量存在最大窗口：如果分区的多数方面已经有足够的时间将从节点选为主节点，则少数端的每个主节点都会提供接受写入。</p><p>这段时间是Redis Cluster的一个非常重要的配置指令，称为节点超时。节点超时过后，主节点会被视为失败，可以由其中一个从节点替换。类似地，在节点超时已经过去而主节点无法感知大多数其他主节点之后，它进入错误状态并且停止接收写入。</p><h1 id="Redis集群参数配置"><a href="#Redis集群参数配置" class="headerlink" title="Redis集群参数配置"></a>Redis集群参数配置</h1><p>我们即将创建一个示例集群部署。在继续之前，让我们介绍Redis Cluster在redis.conf文件中引入的配置参数，有些会很明显，有些会在你继续阅读之后会变得更加清晰。</p><ul><li><strong>cluster-enable &lt;yes/no&gt;</strong>：如果是，则在特定Redis实例中启用Redis集群支持。否则，实例像往常一样作为独立实例运行。</li><li><strong>cluster-config-file <filename></filename></strong>：请注意，尽管此选项的名称这不是用户可编辑的配置文件，但每次发生更改时，Redis Cluster节点会自动保持集群配置（基本上是状态）的文件，以便能够在启动时重新读取它。该文件列出了集群中其他的节点、状态、持久变量等内容。由于某些消息接收，通常会将此文件重写并刷新到磁盘上。</li><li><strong>cluster-node-timeout <milliseconds></milliseconds></strong>：在超时时间内，集群节点不会被视为无效。如果主节点的可访问时间超过指定时间，则其从属节点将进行故障转移。此参数控制Redis集群中其他重要的事项。值得注意的是，在指定时间内无法访问大多数主节点的每个节点都将停止接受查询。</li><li><strong>cluster-save-validity-factor <factor></factor></strong>：如果设置为零，则从站将始终尝试故障转移主站，无论主站和从站之间的链路保持断开连接的时间长短。如果值为正，则计算最大断开时间，因为节点超时值乘以此选项提供的因子，如果节点是从属节点，如果主站断开超过指定时间，它将不会尝试启动故障转移。</li><li><strong>cluster-migration-barrier <count></count></strong></li><li><strong>cluster-require-full-coverage &lt;yes/no&gt;</strong></li></ul><h1 id="创建并使用Redis集群"><a href="#创建并使用Redis集群" class="headerlink" title="创建并使用Redis集群"></a>创建并使用Redis集群</h1><p>注意：要手动部署Redis集群，了解它的某些操作方面非常重要。但是，如果要启动集群并尽快运行，请跳过本节和下一节，然后直接使用<code>create-cluster</code>脚本创建Redis集群。</p><p>要创建集群，我们首先要做的是在集群模式下运行一下空的Redis实例。这基本上意味着，不使用普通的Redis实例创建集群，因为需要配置特殊模式，以便Redis实例启用集群特定的功能和命令。</p><p>以下是最小的Redis集群配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>正如你所看到的，启动集群模式的只是启用集群的指令。每个实例还包含存储此节点配置的文件路1径，默认情况下为<code>nodes.conf</code>，这个文件永远不会被手动编辑，它只是在Redis Cluster实例启动时生成，并在每次需要是更新。</p><p>请注意，按预期工作的最小集群需要包含至少三个主节点。对于你的第一次测试，强烈建议启动具有三个主节点和三个从节点的六节点集群。</p><p>为此，创建一个新目录<code>clusters</code>，并创建以我们将在任何给定目录中运行的实例的端口好命令的一下目录。</p><p>就像是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir clusters</span><br><span class="line">cd clusters</span><br><span class="line">mkdir 7000 7001 7002 7003 7004 7005</span><br></pre></td></tr></table></figure><p>在每个目录下创建一个<code>redis.conf</code>，从7000-7005。作为配置文件的模板，只需要使用上面的小例子，但请确保根据目录名称使用正确的端口号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/redis-server ./clusters/7000/redis.conf</span><br></pre></td></tr></table></figure><p>从每个实例的日志中可以看出，由于不存在<code>nodes.conf</code>文件，因此每个节点都会为自己分配一个新ID。</p><p>此特定实例将永久使用此ID，以使实例在集群的上下文具有唯一名称。每个节点都使用此ID记住每个其他节点，而不是通过IP或者端口记住。IP地址和端口可能会发生变化，但唯一的节点标识符永远不会在节点的整个生命周期内发生变化。我们称这个标识符为<code>Node ID</code>。</p><h2 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h2><p>现在我们已经运行了许多实例，我们需要通过向节点编写一些有意义的配置来创建我们的集群。</p><p>如果你使用的是Redis 5，这很容易实现，因为我们可以使用嵌入到redis-cli的<code>Redis Cluster</code>命令来执行应用，可以用来创建新的集群，检查或者重新部署现有集群等。</p><p>对于Redis版本3和4，有一个名为<code>redis-trib.rb</code>的就工具非常相似。可以在Redis源代码分发的src目录中找到它。你需要安装<code>redis gem</code>才能运行<code>redis-trib</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install redis</span><br></pre></td></tr></table></figure><p>第一个例子，即集群创建，将使用redis 5中的<code>redis-cli</code>和在redis3、4版本中的<code>redis-ctib</code>。但是，所有下面的实例都只是使用<code>redis-cli</code>，因为你可以看到语法非常相似，并且可以通过使用<code>redis-trib.rb</code>帮助获取有关旧语法的信息，从而轻松地将一个命令行更改为另一个命令行。<strong>重要提示</strong>：请注意，如果你愿意，可以将redis 5<code>redis-cli</code>用于redis 4的集群上而不会出现问题。要用<code>redis-cli</code>创建集群，只需要键入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1</span><br></pre></td></tr></table></figure><p>在redis 3或者4键入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br></pre></td></tr></table></figure><p>这里使用的命令是<code>create</code>，因为我们想创建一个新的集群。选项<code>--cluster-replicas 1</code>意味着我们想要为每个创建的主服务创建一个slave。其他参数是我要用于创建新集群的实例的地址列表。</p><p>显然，我们要求的唯一设置是创建一个包含3个主服务器和三个从服务器的集群。</p><p><code>redis-cli</code>将为你提供配置，键入yes接受建议的配置。将配置加入集群，这意味着实例将被引导为彼此通信。最后如果一切顺利，你会看到下面的信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 127.0.0.1:7003 to 127.0.0.1:7000</span><br><span class="line">Adding replica 127.0.0.1:7004 to 127.0.0.1:7001</span><br><span class="line">Adding replica 127.0.0.1:7005 to 127.0.0.1:7002</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Trying to optimize slaves allocation <span class="keyword">for</span> anti-affinity</span></span><br><span class="line">[WARNING] Some slaves are in the same host as their master</span><br><span class="line">M: 126a204fd52df0adede630ad91b3c3434e1ec971 127.0.0.1:7000</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 22f9b0bf8dde6afad4c544b04ead5380745af198 127.0.0.1:7001</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 8b92169294ddd61506372d656efc178c6100abd3 127.0.0.1:7002</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: cbd1967581bf92333cfac27f832cb8a806c0f57d 127.0.0.1:7003</span><br><span class="line">   replicates 22f9b0bf8dde6afad4c544b04ead5380745af198</span><br><span class="line">S: 3e11a361cccf8e9ebc346feba9cc4e2ea4f1db6f 127.0.0.1:7004</span><br><span class="line">   replicates 8b92169294ddd61506372d656efc178c6100abd3</span><br><span class="line">S: 84525e5e43e8e30ee1399294d9d045711fc73fb8 127.0.0.1:7005</span><br><span class="line">   replicates 126a204fd52df0adede630ad91b3c3434e1ec971</span><br><span class="line">Can I set the above configuration? (type 'yes' to accept): yes</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Nodes configuration updated</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span></span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</span></span><br><span class="line">M: 126a204fd52df0adede630ad91b3c3434e1ec971 127.0.0.1:7000</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 22f9b0bf8dde6afad4c544b04ead5380745af198 127.0.0.1:7001</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 84525e5e43e8e30ee1399294d9d045711fc73fb8 127.0.0.1:7005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 126a204fd52df0adede630ad91b3c3434e1ec971</span><br><span class="line">S: cbd1967581bf92333cfac27f832cb8a806c0f57d 127.0.0.1:7003</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 22f9b0bf8dde6afad4c544b04ead5380745af198</span><br><span class="line">S: 3e11a361cccf8e9ebc346feba9cc4e2ea4f1db6f 127.0.0.1:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 8b92169294ddd61506372d656efc178c6100abd3</span><br><span class="line">M: 8b92169294ddd61506372d656efc178c6100abd3 127.0.0.1:7002</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><p>这意味着至少有一个主实例为16384个可用槽提供服务。</p><h2 id="使用create-cluster脚本创建Redis集群"><a href="#使用create-cluster脚本创建Redis集群" class="headerlink" title="使用create-cluster脚本创建Redis集群"></a>使用<code>create-cluster</code>脚本创建Redis集群</h2><p>如果你不想通过如上述手动配置和执行单个实例来创建redis集群，则可以使用更简单的系统。</p><p>只需要检查<code>utils/create-cluster</code>目录即可。里面有一个名为<code>create-cluster</code>的脚本，它是一个简单的bash脚本。要启动具有3个主服务器和3个从服务器的6节点集群，只需要键入一下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create-cluster start</span><br><span class="line">create-cluster create</span><br></pre></td></tr></table></figure><p>当<code>redis-cli</code>实例程序要求你接受集群布局时，在步骤2中回复yes。</p><p>现在你可以与集群交互，默认情况下，第一个节点将从端口30001开始，完成后，使用一下命令停止集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-cluster stop</span><br></pre></td></tr></table></figure><p>有关如何运行脚本的更多信息，请阅读此目录下的<code>README</code>。</p><h2 id="畅玩集群"><a href="#畅玩集群" class="headerlink" title="畅玩集群"></a>畅玩集群</h2><p>在此阶段，Redis集群的一个问题是缺少客户端库实现，我知道以下实现：</p><ul><li><a href="http://github.com/antirez/redis-rb-cluster" target="_blank" rel="noopener">redis-rb-cluster</a> 是作者编写的Ruby实现，作为其他的语言的参考。它是原始redis-rb的简单包装器，实现了最小的定义，可以有效的与集群通信。</li><li><a href="https://github.com/Grokzen/redis-py-cluster" target="_blank" rel="noopener">redis-py-cluster</a> Python的redis集群客户端，支持大多数的功能，正在积极开发中。</li><li><a href="https://github.com/nrk/predis" target="_blank" rel="noopener">predis</a> predis支持redis集群，最近更新了支持并且正在积极开发中。</li><li><a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">jredis</a> 最常用的Java客户端，最近添加了对Redis集群的支持，请参阅项目README中的jredis集群部分。</li><li><a href="https://github.com/StackExchange/StackExchange.Redis" target="_blank" rel="noopener">StackExchange.Redis</a> 提供对C#的支持（并且应该适用于大多数.net语言、VB、F#等）</li><li><a href="https://github.com/thunks/thunk-redis" target="_blank" rel="noopener">thunk-redis</a> 支持Node.js和io.js，它是基于thunk/promise的redis客户端，具有流水线和集群。</li><li><a href="https://github.com/chasex/redis-go-cluster" target="_blank" rel="noopener">redis-go-cluster</a> 是使用Redigo库客户端作为基本客户端的Go语言Redis集群的实现。通过结果聚合实现MEGT/MSET。</li><li><a href>redis-cli</a></li></ul><p>测试Redis集群的一种简单方法是尝试上述任何客户端或者简单的使用redis-cli命令行实用程序。以下是使用后者的交互示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">19:54:06 › ./bin/redis-cli -c -p 7000</span><br><span class="line">127.0.0.1:7000&gt; set foo bar</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [12182] located at 127.0.0.1:7002</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7002&gt; set hello world</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [866] located at 127.0.0.1:7000</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7000&gt; get foo</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [12182] located at 127.0.0.1:7002</span></span><br><span class="line">"bar"</span><br><span class="line">127.0.0.1:7002&gt; get hello</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [866] located at 127.0.0.1:7000</span></span><br><span class="line">"world"</span><br></pre></td></tr></table></figure><p>注意，如果使用脚本创建集群，则节点可以监听不同的端口，默认情况下从30001开始。</p><p>redis-cli集群支持非常基础，因此它始终使用Redis集群节点能够保持客户端重定向到右节点的事实。一个严肃的客户端能够做到很好，并在哈希槽和节点地址之间缓存地图，以直接使用与正确节点的正确连接。仅当集群配置中的某些内容发生变更时（例如，在故障转移之后或系统管理员通过添加或删除节点更改集群后），才会刷新映射。</p><h3 id="使用redis-rb-cluster编写应用程序"><a href="#使用redis-rb-cluster编写应用程序" class="headerlink" title="使用redis-rb-cluster编写应用程序"></a>使用redis-rb-cluster编写应用程序</h3><h3 id="集群重新分片"><a href="#集群重新分片" class="headerlink" title="集群重新分片"></a>集群重新分片</h3><p>现在我们准备尝试重新分片。为此，请保持<code>example.rb</code>程序运行，以便你可以查看是否对运行的程序的一些影响。此外，你可能需要注释睡眠时间，以便在重新分片期间有一些更严重的写入负载。</p><p>重新分片基本上意味着将散列槽从一组节点移动到另一组节点，并且想集群创建一样，它是使用redis-cli命令完成的。</p><p>要重新开始分片，只需输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard 127.0.0.1:7000</span><br></pre></td></tr></table></figure><p>只需指定一个节点，redis-cli将自动找到其他节点。</p><p>目前redis-cli只能通过管理员重新加载，你不能只说将5%的插槽从这个节点移动到另一个节点（但这实现起来非常简单）。所以从这个问题开始，首先是你需要做多大的重新slots：</p><p>我们可以尝试重新刷新1000和散列槽，如果示例仍在没有睡眠调用的情况下运行，那么它应该已包含非常少量的密钥。</p><p>然后redis-cli需要知道重新分片的目标是什么，即接受哈希槽的节点。我将使用第一个节点，即127.0.0.1:7000，但需要指定示例节点的ID，这已由redis-cli打印在列表中，但如果需要，总能使用一下命令找到节点ID：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7000 clusters nodes | grep myself</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 126a204fd52df0adede630ad91b3c3434e1ec971 127.0.0.1:7000@17000 myself,master - 0 1551144977000 1 connected 0-5460</span></span><br></pre></td></tr></table></figure><p>目标节点ID为：126a204fd52df0adede630ad91b3c3434e1ec971</p><p>现在，你将被问到要从哪些节点获取这些密钥，我只需要键入<code>all</code>即可从所有其他主节点获取一些哈希槽。</p><p>在最终确认之后，将会看到redis-cli将从一个节点移动到另一个节点的每一个槽的消息，并且将为从一侧移动到另一侧的每个实际键打印一个点。</p><p>重新分片正在进行中，你应该可以看到示例程序不受影响的运行。如果需要，你可以在重新分片期间多次停止并重新启动他们。</p><p>在重新分片结束时，可以使用以下命令测试集群的运行情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster check 127.0.0.1:7000</span><br></pre></td></tr></table></figure><p>所有的插槽都会像往常一样覆盖，但这次127.0.0.1:7000的主机将有更多的散列槽，大约6461个。</p><h3 id="编写重新分片脚本"><a href="#编写重新分片脚本" class="headerlink" title="编写重新分片脚本"></a>编写重新分片脚本</h3><p>可以自动执行重新分片，而无需以交互手动输入方式。这可以使用如下命令行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli reshard &lt;host&gt;:&lt;port&gt; --cluster-from &lt;node-id&gt; --cluster-to &lt;node-id&gt; --cluster-slots &lt;number of slots&gt; --cluster-yes</span><br></pre></td></tr></table></figure><p>如果经常需要进行分片操作，可以创建一些自动化脚本，但是目前redis-cli无法自动重新平衡集群，检查集群节点上密钥的分布情况，并根据需要只能地移动插槽。此功能将在未来添加。</p><h3 id="更有趣的示例"><a href="#更有趣的示例" class="headerlink" title="更有趣的示例"></a>更有趣的示例</h3><p>我们早期写的示例程序不是很好，它是以简单的方式写入集群，甚至不检查写入的内容是否正确。</p><p>从我们的角度来看，接受写入的集群可能总是将密钥foo写入42到每个操作，我们根本不会注意到。</p><p>所以在<code>redis-rb-cluster</code>存储库中，有一个更有趣的应用程序叫做<code>consistency-test.rb</code>。它使用一组计数器，默认为1000，并发送INCR命令以递增计数器。</p><p>然而，改应用程序不仅仅是编写，而是执行另外两项操作：</p><ul><li>使用INCR更新计数器时，应用程序会记住写入</li><li>它还在每次写入之前读取一个随机计数器，并检查改值是否与我们预期的值相比，将其与内存中的值进行比较</li></ul><h3 id="测试故障转移"><a href="#测试故障转移" class="headerlink" title="测试故障转移"></a>测试故障转移</h3><p>注意，在此测试期间，应该打开一个终端，并运行一致性测试应用程序。</p><p>为了触发故障转移，我们可以做的最简单的事情（也就是在分布式系统中可能出现的语义上最简单的故障）是使单个进程崩溃，在我们的示例中是单个进程。</p><p>我们可以使用一下命令识别集群并使其崩溃：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7000 cluster nodes | grep master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 22f9b0bf8dde6afad4c544b04ead5380745af198 127.0.0.1:7001@17001 master - 0 1551170676000 2 connected 5962-10922</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 126a204fd52df0adede630ad91b3c3434e1ec971 127.0.0.1:7000@17000 myself,master - 0 1551170676000 7 connected 0-5961 10923-11421</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 8b92169294ddd61506372d656efc178c6100abd3 127.0.0.1:7002@17002 master - 0 1551170676578 3 connected 11422-16383</span></span><br></pre></td></tr></table></figure><p>让我们用<code>debug segfault</code>命令崩溃节点7002：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7002 debug segfault</span><br></pre></td></tr></table></figure><p>现在我们可以查看一致性测试的输出，看看它报告了什么：</p><h3 id="添加新节点"><a href="#添加新节点" class="headerlink" title="添加新节点"></a>添加新节点</h3><p>添加新节点基本上是添加空节点然后将一些数据移入其中的过程，以防它是新的主节点，或者告诉它设置为已知节点的副本，以防它是从属节点。</p><p>我们将展示两者，从添加新的主服务器开始。</p><p>在两种情况下，执行的第一步是添加空节点。</p><p>这很简单，只需在端口7006中启动一个新节点（我们现在已经有6个节点，端口从7000-7005）其他节点使用相同的配置，端口号除外，那么你应该怎么做才能符合我们以前节点使用的设置：</p><ul><li>在终端应用程序中创建一个新选项卡</li><li>进入<code>cluter</code>目录</li><li>创建7006目录</li><li>在里面创建一个<code>redis.conf</code>文件，类似于用于其他节点但使用7006端口的文件</li><li>最庸使用<code>./bin/redis-server ./cluster/7006/redis.conf</code>启动服务器</li></ul><p>此时，服务器应该在运行。</p><p>现在我们可以想往常一样使用<code>redis-cli</code>命令以便将节点添加到我们集群中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000</span><br></pre></td></tr></table></figure><p>如你所见，我使用<code>add-node</code>命令将新节点的地址指定为第一个参数，并将集群中随机存在节点的地址指定为第二个参数。</p><p>实际上，<code>redis-cli</code>在这方面做的好少帮助我们，它只是向节点发送一个<code>CLUSTER MEET</code>详细，这也可以手动完成。但是<code>redis-cli</code>在运行之前也会检查集群的状态，所以即使你知道内部是如何运行的，也总是通过<code>redis-cli</code>执行集群操作是个好主意。</p><p>现在我们可以连接到新节点以查看它是否真正加入集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请注意，由于此节点已连接到集群，因此它已能够正确地重定向客户端查询，并且通常是集群的一部分。然而，与其他master相比，它有两个特点：</p><ul><li>它没有数据，因为它没有分配哈希槽</li><li>因为它是没有分配插槽的主节点，所有当从服务器成为主节点时，它不参与选举过程</li></ul><p>现在可以使用<code>redis-cli</code>的重新分片功能为此节点分配哈希槽。显示这一点基本没用，就像我们在上一节中所做的那样，没有区别，它只是一个重新分区，具有空节点的目标。</p><h3 id="添加新节点为副本"><a href="#添加新节点为副本" class="headerlink" title="添加新节点为副本"></a>添加新节点为副本</h3><p>添加新副本可以通过两种方式进行。显而易见的是再次使用<code>redis-cli</code>，但使用<code>--cluster-slave</code>选项，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000 --cluster-slave</span><br></pre></td></tr></table></figure><p>请注意，此处的命令行与我们用于添加新主服务器的命令完全相同，因此我们不指定要添加副本的主服务器。在这种情况下，会发生的事情是<code>redis-cli</code>会将新节点作为随机主副本的副本添加到副本较少的主服务器中。</p><p>但是，你可以使用一下命令行准确指定要使用新副本定位的主服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000 --cluster-slave --cluster-master-id xasf2k45s2341gf9f0hh0fldnylxiu</span><br></pre></td></tr></table></figure><p>这样我们就可以将新副本分配给特定的主副本。</p><p>将副本添加到特定主节点的手动方法是将新节点添加为空主节点，然后使用<code>cluster replicate</code>命令将其转换为副本。如果节点作为从属节点添加，但你想将其作为不同节点的副本移动，则此方法也是有效的。</p><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>要删除从属节点，只需要使用<code>redis-cli</code>的<code>del-node</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster del-node 127.0.0.1:7000 &lt;node-id&gt;</span><br></pre></td></tr></table></figure><p>第一个参数只是集群中的随机节点，第二个参数是要删除节点的ID。</p><p>你也可以以相同的方式删除主节点，但是为了删除主节点，它必须为空。如果主服务器不为空，则需要将数据从其重新分配给所有其他主节点。删除主节点的另一种方法是在其中一个节点上手动故障转移，并在节点变为新主节点的从节点后将其删除。显然，当你想减少集群中实际的主数量时，这没有用，在这种情况下，需要重新分片。</p><h3 id="副本迁移"><a href="#副本迁移" class="headerlink" title="副本迁移"></a>副本迁移</h3><p>在Redis集群中，只需要使用一下命令，就可以随时使用不同的主服务器重新配置从属服务器进行复制：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER REPLICATE &lt;master-node-id&gt;</span><br></pre></td></tr></table></figure><p>但是，有一种特殊情况，你希望副本在没有系统管理员帮助的情况下自动从一个主服务器移动到另一个主服务器。副本的自动重新配置称为服务迁移，并且能够提高Redis集群的可靠性。</p><p>注意：你可以在Redis集群规范中阅读副本迁移的详细信息，这里我们仅提供有关一般概念的一些信息以及你应该从中获益的信息。</p><p>你可能希望让集群副本在特定情况下从一个主服务器移动到另一个主服务器的原因是，通常Redis集群与附加到给定主服务器的副本数量一样可以抵御故障。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是翻译redis官网的一篇文章，并且加上作者的一些理解而成。若理解错误，请提出批评。&lt;/p&gt;
&lt;p&gt;原文请查看 &lt;strong&gt;&lt;a href=&quot;https://redis.io/topics/cluster-tutorial#redis-cluster-101&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis cluster tutorial&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://lvyun66.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://lvyun66.github.io/tags/Redis/"/>
    
      <category term="Cluster" scheme="https://lvyun66.github.io/tags/Cluster/"/>
    
  </entry>
  
  <entry>
    <title>fopen中mode详解</title>
    <link href="https://lvyun66.github.io/2018/12/10/Linux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cmode%E8%AF%A6%E8%A7%A3/"/>
    <id>https://lvyun66.github.io/2018/12/10/Linux文件操作mode详解/</id>
    <published>2018-12-10T16:49:14.000Z</published>
    <updated>2019-08-30T08:19:44.318Z</updated>
    
    <content type="html"><![CDATA[<p>文件操作是一个很平常的一个操作，打开文件、写入文件已经关闭文件等操作。不同模式打开文件会有不同的效果。有一些<code>mode</code>会比较容易混淆，在此记录下它们之间的区别。</p><a id="more"></a><p><code>mode</code>模式：</p><ol><li><code>r</code>：以只读模式打开文件，将文件指针指向文件头；</li><li><code>r+</code>：以读写模式打开文件，将文件指针指向开头；</li><li><code>w</code>：以只读模式打开文件，将文件指针指向文件头并将文件大小截为0，如果文件不存在则尝试创建；</li><li><code>w+</code>：以读写模式打开文件，将文件指正指向文件头并将文件大小截为0，如果文件不存在则尝试创建；</li><li><code>a</code>：以写入模式打开文件，将文件指针指向文件结尾，如果文件不存在则尝试创建；</li><li><code>a+</code>：以读写模式打开文件，将文件指针指向文件结尾，如果文件不存在则尝试创建；</li><li><code>x</code>：创建并以写入模式打开文件，将文件指正指向文件开头，如果文件已存在，则<code>fopen</code>调用失败，返回<code>false</code>，如果不存在则尝试创建；</li><li><code>x+</code>：创建并读写模式打开文件，将文件指针指向文件开头，如果文件已存在，则<code>fopen</code>调用失败，返回<code>false</code>，如果不存在则尝试创建；</li></ol><p>其中我们最容易混淆的两个模式就是<code>r+</code>和<code>w+</code>，这两个模式都是以读写方式打开文件，但之间有何区别呢？</p><p><code>r+</code>不会将文件清空，将文件指针指向文件开头，如果文件不为空，内容会被新写入的覆盖。</p><p>假设文件<code>test.txt</code>内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is testing for fprintf 5...</span><br><span class="line">This is testing for fputs 6</span><br><span class="line">This is testing for fprintf 7...</span><br><span class="line">This is testing for fputs 8</span><br></pre></td></tr></table></figure><p>php代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$filename = <span class="string">'test.txt'</span>;</span><br><span class="line">$fp = fopen($filename, <span class="string">'r+'</span>);</span><br><span class="line">fprintf($fp, <span class="string">"This is testing for fprintf 7...\n"</span>);</span><br><span class="line">fputs($fp, <span class="string">"This is testing for fputs 8\n"</span>);</span><br><span class="line">fclose($fp);</span><br></pre></td></tr></table></figure><p>最终结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is testing for fprintf 7...</span><br><span class="line">This is testing for fputs 8</span><br><span class="line">This is testing for fprintf 7...</span><br><span class="line">This is testing for fputs 8</span><br></pre></td></tr></table></figure><p><code>w+</code>会清空文件内容，将文件指正指向文件开头，类似与先将文件删除，再新建文件，最后把新内容写入文件中；如果要打开的文件不存在则会创建。</p><p>That`s all！Thx.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文件操作是一个很平常的一个操作，打开文件、写入文件已经关闭文件等操作。不同模式打开文件会有不同的效果。有一些&lt;code&gt;mode&lt;/code&gt;会比较容易混淆，在此记录下它们之间的区别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="https://lvyun66.github.io/tags/PHP/"/>
    
      <category term="fopen" scheme="https://lvyun66.github.io/tags/fopen/"/>
    
  </entry>
  
  <entry>
    <title>Yii2源码分析(8)-运行流程</title>
    <link href="https://lvyun66.github.io/2018/12/08/Yii2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(8)-%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://lvyun66.github.io/2018/12/08/Yii2源码分析(8)-运行流程/</id>
    <published>2018-12-08T20:12:01.000Z</published>
    <updated>2019-08-30T08:19:44.322Z</updated>
    
    <content type="html"><![CDATA[<p>Yii2</p><a id="more"></a><h2 id="入口文件-index-php"><a href="#入口文件-index-php" class="headerlink" title="入口文件(index.php)"></a>入口文件(index.php)</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Yii2&lt;/p&gt;
    
    </summary>
    
      <category term="Yii2" scheme="https://lvyun66.github.io/categories/Yii2/"/>
    
    
      <category term="PHP" scheme="https://lvyun66.github.io/tags/PHP/"/>
    
      <category term="Yii2" scheme="https://lvyun66.github.io/tags/Yii2/"/>
    
  </entry>
  
  <entry>
    <title>Yii2源码分析(7)-Application</title>
    <link href="https://lvyun66.github.io/2018/12/07/Yii2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(7)-Application/"/>
    <id>https://lvyun66.github.io/2018/12/07/Yii2源码分析(7)-Application/</id>
    <published>2018-12-07T19:18:54.000Z</published>
    <updated>2019-08-30T08:19:44.322Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Yii2" scheme="https://lvyun66.github.io/categories/Yii2/"/>
    
    
      <category term="PHP" scheme="https://lvyun66.github.io/tags/PHP/"/>
    
      <category term="Yii2" scheme="https://lvyun66.github.io/tags/Yii2/"/>
    
  </entry>
  
  <entry>
    <title>Yii2源码分析(6)-Module</title>
    <link href="https://lvyun66.github.io/2018/12/06/Yii2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(6)-Module/"/>
    <id>https://lvyun66.github.io/2018/12/06/Yii2源码分析(6)-Module/</id>
    <published>2018-12-06T19:18:33.000Z</published>
    <updated>2019-08-30T08:19:44.322Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Yii2" scheme="https://lvyun66.github.io/categories/Yii2/"/>
    
    
      <category term="PHP" scheme="https://lvyun66.github.io/tags/PHP/"/>
    
      <category term="Yii2" scheme="https://lvyun66.github.io/tags/Yii2/"/>
    
  </entry>
  
  <entry>
    <title>Yii2源码分析(5)-ServiceLocator</title>
    <link href="https://lvyun66.github.io/2018/12/05/Yii2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(5)-ServiceLocator/"/>
    <id>https://lvyun66.github.io/2018/12/05/Yii2源码分析(5)-ServiceLocator/</id>
    <published>2018-12-05T19:18:45.000Z</published>
    <updated>2019-08-30T08:19:44.322Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Yii2" scheme="https://lvyun66.github.io/categories/Yii2/"/>
    
    
      <category term="PHP" scheme="https://lvyun66.github.io/tags/PHP/"/>
    
      <category term="Yii2" scheme="https://lvyun66.github.io/tags/Yii2/"/>
    
  </entry>
  
  <entry>
    <title>Yii2源码分析(4)-Component</title>
    <link href="https://lvyun66.github.io/2018/12/04/Yii2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(4)-Component/"/>
    <id>https://lvyun66.github.io/2018/12/04/Yii2源码分析(4)-Component/</id>
    <published>2018-12-04T10:57:48.000Z</published>
    <updated>2019-08-30T08:19:44.322Z</updated>
    
    <content type="html"><![CDATA[<p><code>Component</code>是实现<code>behavior</code>、<code>event</code>和<code>property</code>特性的基类，提供<code>行为</code>和<code>事件</code>的能力；<code>Component</code>可包含多个<code>behavior</code>，<code>behavior</code>可以包含多个<code>event</code>。</p><a id="more"></a><p><code>Event</code>是一种将自定义代码<code>注入</code>到现有代码中的方法，当触发事件时，通过<code>call_user_func()</code>回调事件处理函数达到注入的效果；<code>Behavior</code>可用于增加现有组件功能而无需修改代码的方式。</p><h2 id="组件-Component-的构成"><a href="#组件-Component-的构成" class="headerlink" title="组件(Component)的构成"></a>组件(Component)的构成</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><ol><li><strong>$_events</strong> 存储组件绑定的事件</li><li><strong>$_eventWildcards</strong> 存储时间通配符</li><li><strong>$_behaviors</strong> 组件绑定的行为</li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li><p><strong>__get($name)</strong> 返回组件的属性值, 不仅实现<code>BaseObject</code>类中的基本功能, 也会获取<code>Behavior</code>中的属性, 达到把行为中的属性注入到组件中的效果</p></li><li><p><strong>__set($name, $value)</strong> 设置组件的属性. 会依次检查<code>组件中的setter</code>、<code>event</code>和<code>behavior中的setter</code></p></li><li><p><strong>__isset($name)</strong> 检验属性是否被设置</p></li><li><p><strong>__unset($name)</strong> 设置组件的属性为<code>null</code></p></li><li><p><strong>__call($name, $param)</strong> 调用不存在的方法时，检查行为中是否存在</p></li><li><p><strong>__clone()</strong> 克隆组件清除所有变量的值</p></li><li><p><strong>hasProperty()</strong> 是否包含属性，会依次检查<code>component的getter和setter</code>、<code>component的变量</code>以及<code>绑定在组件上的行为的属性</code></p></li><li><p><strong>canGetProperty()、canSetProperty()</strong> 检查属性是否有读写能力，检查范围同<code>hasProperty()</code></p></li><li><p><strong>hasMethod()</strong> 检查组件、行为中是否存在方法</p></li><li><p><strong>behaviors()</strong> 绑定在组件上的行为列表，数组结构表示如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'behaviorName'</span> =&gt; [</span><br><span class="line">    <span class="string">'class'</span> =&gt; <span class="string">'BehaviorName'</span>,</span><br><span class="line">    <span class="string">'property1'</span> =&gt; <span class="string">'value1'</span>,</span><br><span class="line">    <span class="string">'property2'</span> =&gt; <span class="string">'value2'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p><strong>hasEventHandlers()</strong> 组件是否包含事件处理函数</p></li><li><p><strong>on()</strong> 将事件绑定到组件</p></li><li><p><strong>off()</strong> 将事件与组件解绑</p></li><li><p><strong>trigger()</strong> 触发组件事件</p></li><li><p><strong>getBehavior()</strong> 获取行为对象</p></li><li><p><strong>getBehaviors()</strong> 获取组件所有行为</p></li><li><p><strong>attachBehavior()、attachBehaviors()</strong> 绑定行为到组件上</p></li><li><p><strong>detachBehavior()、detachBehaviors()</strong> 解绑组件上的行为</p></li><li><p><strong>ensureBehaviors()</strong> 确保<code>behaviors()</code>上的所有行为已经绑定到组件上</p></li><li><p><strong>attachBehaviorInternal()</strong> 绑定一个行为对象到组件的<code>$_behaviors</code>属性上</p></li></ol><p>可以将<code>Component</code>的方法分为三类：</p><ol><li>属性类</li><li>事件类</li><li>行为类</li></ol><h2 id="如何实现property特性"><a href="#如何实现property特性" class="headerlink" title="如何实现property特性"></a>如何实现property特性</h2><p><code>Component</code>继承与<code>BaseObject</code>，因此只需要继承、覆盖魔术方法<code>__get()、__set()</code>即可实现<code>属性</code>特性。下面是<code>__get()、__set()</code>实现代码：</p><h3 id="get"><a href="#get" class="headerlink" title="__get()"></a>__get()</h3><ol><li>检查组件中是否包含<code>getter</code>方法</li><li>遍历所有行为是否存在属性</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span><span class="params">($name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// step1 检查组件是否办好getName()方法</span></span><br><span class="line">    $getter = <span class="string">'get'</span> . $name;</span><br><span class="line">    <span class="keyword">if</span> (method_exists(<span class="keyword">$this</span>, $getter)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;$getter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step1 行为中是否包含属性</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;ensureBehaviors();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;_behaviors <span class="keyword">as</span> $behavior) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($behavior-&gt;canGetProperty($name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> $behavior-&gt;$name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method_exists(<span class="keyword">$this</span>, <span class="string">'set'</span> . $name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidCallException(<span class="string">'Getting write-only property: '</span> . get_class(<span class="keyword">$this</span>) . <span class="string">'::'</span> . $name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnknownPropertyException(<span class="string">'Getting unknown property: '</span> . get_class(<span class="keyword">$this</span>) . <span class="string">'::'</span> . $name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="__set()"></a>__set()</h3><ol><li>检查组件是否存在set方法</li><li>是否以<code>on</code>开头的绑定事件</li><li><code>as</code>绑定行为</li><li>检查行为中是否存在set方法</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span><span class="params">($name, $value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $setter = <span class="string">'set'</span> . $name;</span><br><span class="line">    <span class="keyword">if</span> (method_exists(<span class="keyword">$this</span>, $setter)) &#123;</span><br><span class="line">        <span class="comment">// set property</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;$setter($value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">elseif</span> (strncmp($name, <span class="string">'on '</span>, <span class="number">3</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// on event: attach event handler</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;on(trim(substr($name, <span class="number">3</span>)), $value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">elseif</span> (strncmp($name, <span class="string">'as '</span>, <span class="number">3</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// as behavior: attach behavior</span></span><br><span class="line">        $name = trim(substr($name, <span class="number">3</span>));</span><br><span class="line">        <span class="keyword">$this</span>-&gt;attachBehavior($name, $value <span class="keyword">instanceof</span> Behavior ? $value : Yii::createObject($value));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// behavior property</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;ensureBehaviors();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;_behaviors <span class="keyword">as</span> $behavior) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($behavior-&gt;canSetProperty($name)) &#123;</span><br><span class="line">            $behavior-&gt;$name = $value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method_exists(<span class="keyword">$this</span>, <span class="string">'get'</span> . $name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidCallException(<span class="string">'Setting read-only property: '</span> . get_class(<span class="keyword">$this</span>) . <span class="string">'::'</span> . $name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnknownPropertyException(<span class="string">'Setting unknown property: '</span> . get_class(<span class="keyword">$this</span>) . <span class="string">'::'</span> . $name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="行为的绑定"><a href="#行为的绑定" class="headerlink" title="行为的绑定"></a>行为的绑定</h2><p>重载<code>Component::behavior()</code>方法即可绑定行为到组件上。</p><p><strong>内部原理</strong>：</p><p>首先我们会注意到<code>ensureBehaviors()</code>这个方法会在<code>__get()、__set()</code>以及<code>__call()</code>等魔术方法中调用，保证行为中的属性被注入到<code>Component</code>。</p><p>通过查看调用栈可以看出函数的调用顺下如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Component-&gt;ensureBehaviors()</span><br><span class="line"><span class="number">2.</span> Component-&gt;attachBehaviorInternal()</span><br><span class="line"><span class="number">3.</span> Behavior-&gt;attach()</span><br><span class="line"><span class="number">4.</span> Component-&gt;on()</span><br><span class="line"><span class="number">5.</span> Component-&gt;ensureBehaviors()</span><br></pre></td></tr></table></figure><h3 id="ensureBehaviors"><a href="#ensureBehaviors" class="headerlink" title="ensureBehaviors"></a>ensureBehaviors</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">ensureBehaviors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;_behaviors === <span class="keyword">null</span>) &#123;   <span class="comment">// 判断成员变量是否===null，注意是恒等于</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;_behaviors = [];         <span class="comment">// 这一句很关键，如果没有这一句，会形成一个死循环</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;behaviors() <span class="keyword">as</span> $name =&gt; $behavior) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;attachBehaviorInternal($name, $behavior);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很简单，通过<code>foreach</code>把行为通过<code>attachBehaviorInternal()</code>绑定到<code>$this</code>组件上。</p><p>请一定注意<code>$this-&gt;_behaviors = [];</code>这一段代码，如果我们忽略这一句的重要性，将会影响我们理解。</p><p>当第一次执行<code>Component-&gt;ensureBehaviors()</code>时，会把<code>$this-&gt;_behaviors = [];</code>，当第二次执行<code>Component-&gt;ensureBehaviors()</code>函数时，由于<code>$this-&gt;_behaviors === null</code>从而直接退出。</p><h3 id="attachBehaviorInternal"><a href="#attachBehaviorInternal" class="headerlink" title="attachBehaviorInternal"></a>attachBehaviorInternal</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">attachBehaviorInternal</span><span class="params">($name, $behavior)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!($behavior <span class="keyword">instanceof</span> Behavior)) &#123;</span><br><span class="line">        $behavior = Yii::createObject($behavior);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is_int($name)) &#123;</span><br><span class="line">        $behavior-&gt;attach(<span class="keyword">$this</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;_behaviors[] = $behavior;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;_behaviors[$name])) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;_behaviors[$name]-&gt;detach();</span><br><span class="line">        &#125;</span><br><span class="line">        $behavior-&gt;attach(<span class="keyword">$this</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;_behaviors[$name] = $behavior;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $behavior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个私有函数，可以看出绑定行为只能在<code>Component</code>中进行。</p><p>这个函数主要做了下面几件事：</p><ol><li>判断<code>$behavior</code>是否为继承<code>Behavior</code>类的实例，如果不是则通过<code>Yii::createObject()</code>创建；</li><li>是否以匿名方式绑定，若是直接绑定；</li><li>若是命名行为，判断行为是否存在<code>Component</code>中，如果则先解绑改行为，然后重新绑定到<code>Component</code>上。</li></ol><p>从执行步骤可以看出，如果是命名行为，后声明的会先声明的行为。但是匿名行为不会。</p><h3 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">attach</span><span class="params">($owner)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;owner = $owner;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;events() <span class="keyword">as</span> $event =&gt; $handler) &#123;</span><br><span class="line">        $owner-&gt;on($event, is_string($handler) ? [<span class="keyword">$this</span>, $handler] : $handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>attach</code>是<code>Behavior</code>中的方法。做两件事：</p><ol><li>设置行为的<code>$owner</code>，将行为依附在<code>Component</code>上；</li><li>遍历行为中的事件，将事件绑定到<code>Component</code>上。</li></ol><h3 id="on"><a href="#on" class="headerlink" title="on"></a>on</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">on</span><span class="params">($name, $handler, $data = null, $append = true)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;ensureBehaviors();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strpos($name, <span class="string">'*'</span>) !== <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($append || <span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;_eventWildcards[$name])) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;_eventWildcards[$name][] = [$handler, $data];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            array_unshift(<span class="keyword">$this</span>-&gt;_eventWildcards[$name], [$handler, $data]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($append || <span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;_events[$name])) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;_events[$name][] = [$handler, $data];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        array_unshift(<span class="keyword">$this</span>-&gt;_events[$name], [$handler, $data]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>on()</code>函数的作用是把事件依附在<code>Component</code>上，如果包含通配符，在放到<code>$_eventWildcards</code>成员变量中；如果是正常的命名事件，则放到<code>$_events</code>;</p><h2 id="行为响应事件"><a href="#行为响应事件" class="headerlink" title="行为响应事件"></a>行为响应事件</h2><p>通过行为注入，可以在不修改现有类的情况下，更改、扩展类对于事件的响应和支持。如何将行为与<code>Component</code>的事件关联起来，就必须通过<code>Behavior</code>的<code>events()</code>方法。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">events</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        BaseActiveRecord::EVENT_BEFORE_INSERT =&gt; [<span class="keyword">$this</span>, <span class="string">'callback_function'</span>],</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过覆盖<code>events()</code>方法，当<code>Behavior</code>与<code>Component</code>绑定时，会调用<code>Behavior::attach()</code>方法。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到此，<code>Component</code>的重要特性基本上已经梳理了，重点理解组件是如何绑定行为以及事件是如何依附在组件之上和行为是如何响应事件等原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Component&lt;/code&gt;是实现&lt;code&gt;behavior&lt;/code&gt;、&lt;code&gt;event&lt;/code&gt;和&lt;code&gt;property&lt;/code&gt;特性的基类，提供&lt;code&gt;行为&lt;/code&gt;和&lt;code&gt;事件&lt;/code&gt;的能力；&lt;code&gt;Component&lt;/code&gt;可包含多个&lt;code&gt;behavior&lt;/code&gt;，&lt;code&gt;behavior&lt;/code&gt;可以包含多个&lt;code&gt;event&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Yii2" scheme="https://lvyun66.github.io/categories/Yii2/"/>
    
    
      <category term="PHP" scheme="https://lvyun66.github.io/tags/PHP/"/>
    
      <category term="Yii2" scheme="https://lvyun66.github.io/tags/Yii2/"/>
    
  </entry>
  
  <entry>
    <title>Yii2源码分析(3)-Behavior</title>
    <link href="https://lvyun66.github.io/2018/12/03/Yii2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(3)-Behavior/"/>
    <id>https://lvyun66.github.io/2018/12/03/Yii2源码分析(3)-Behavior/</id>
    <published>2018-12-03T19:22:37.000Z</published>
    <updated>2019-08-30T08:19:44.322Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Yii2" scheme="https://lvyun66.github.io/categories/Yii2/"/>
    
    
      <category term="PHP" scheme="https://lvyun66.github.io/tags/PHP/"/>
    
      <category term="Yii2" scheme="https://lvyun66.github.io/tags/Yii2/"/>
    
  </entry>
  
  <entry>
    <title>Yii2源码分析(2)-Event</title>
    <link href="https://lvyun66.github.io/2018/12/02/Yii2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(2)-Event/"/>
    <id>https://lvyun66.github.io/2018/12/02/Yii2源码分析(2)-Event/</id>
    <published>2018-12-02T19:22:04.000Z</published>
    <updated>2019-08-30T08:19:44.322Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Yii2" scheme="https://lvyun66.github.io/categories/Yii2/"/>
    
    
      <category term="PHP" scheme="https://lvyun66.github.io/tags/PHP/"/>
    
      <category term="Yii2" scheme="https://lvyun66.github.io/tags/Yii2/"/>
    
  </entry>
  
</feed>
